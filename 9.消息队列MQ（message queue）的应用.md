# 消息队列中间件

### 1.消息队列的应用场景

```sh
    消息队列中间件主要是分布式系统中的重要组件，主要解决异步消息，应用解耦，流量销峰等问题，从而实现高性能、高可用、可伸缩和最终一致性架构
```

##### 1.1异步处理

>```sh
>#场景说明：用户注册后需要发送注册邮件和注册短信
>```
>
>```sh
>2.引入消息队列：异步处理，注册消息写入数据库后即返回客户端注册成功
>```
>

##### 1.2应用解耦

>```sh
>#场景说明：用户下单后，下单系统需要通知库存系统
>```
>
>```sh
>1.传统做法：订单系统调用库存系统接口，待库存系统正确返回给订单系统，订单系统才会返回客户端下单成功
>     缺点：假如库存系统无法访问，订单减库存将失败，从而下单失败，订单系统与库存系统耦合	
>```
>
>```sh
>2.引入消息队列：
>订单系统：用户下单后，订单系统完成持久化处理，将消息写入队列，就可返回用户，下单成功
>库存系统：订阅下单消息，获取下单信息，库存消息根据下单信息，进行库存操作
>  假如：下单时库存系统不能正常使用，也不会影响正常下单。因为下单后，系统写入消息队列后就不再关心后续操作了
>    实现订单系统与库存系统的应用解耦	
>  ```
>     

##### 1.3流量销峰

>```sh
>#应用场景：秒杀活动一般因为流量过大，导致流量暴增，应用挂掉
>```
>
>```sh
>1.引入消息队列：
>  可以控制活动人数、可以缓解短时间内高流量压垮应用
>  用户请求，服务器接收后，先写入消息队列，假如消息队列超过最大数量，则直接抛弃用户或返回错误页面
>  秒杀业务根据消息队列中的请求消息，再做后续处理	
>```
>

### 2.消息队列主要用来解决那些问题

##### 2.1Publish/Subscribe

>```sh
>订阅发布是消息中间件最基本功能
>```

##### 2.2Message Priority

>```sh
>  RocketMQ所有消息都是持久化的，所以按照优先级来排序，开销会非常大，因此RocketMQ没有特意支持消息优先级
>  但是可以通过变通的方式实现类似功能，即单独配置一个优先级高的队列，和一个普通优先级别队列，将不同优先级
>  发送到不同队列即可
>  	1.只要达到优先级别目的即可，不是严格意义上的优先级，通常将优先级分为高、中、低或者再多几个级别，每个		  优先级可以用不同topic来表示，发消息时，指定不同topic来表示优先级，这种方式可以解决大部分的优先级		  问题，但是对业务优先级精确性做了拖鞋
>  	2.严格的优先级，用整数0~65535表示，这种优先级问题一般用不同topic解决就非常不合适。如果要让MQ解决此	   问题，会对MQ性能造成非常大的影响。需要明确一点，业务上是否确实需要这种严格的优先级，如果将优先级压	   缩成几个，对业务影响有多大
>```

##### 2.3Message Order

>```sh
>  消息有序指的是一类消息消费时，能按照发送的顺序来消费。
>  如：一个订单产生三条消息，分别是订单创建，订单付款，订单完成。消费时，按照这个顺序消费才有意义，单同时订	   单直接可以并行消费。
>  RocketMQ可以严格保证消息有序
>```

##### 2.4Message Filter

>```sh
>  	1.Broker端消息过滤
>  		在Broker中，按照Consumer的要求做过滤，优点是减少了对于Consumer无用消息的网络传输
>  		缺点是增加了Broker的负担，实现相对复杂
>  	2.Consumer端消息过滤
>  		这种过滤方式可由应用完全自定义实现，但是缺点是很多无用的消息要传输到Consumer端
>```

##### 2.5Message Persistence

>```sh
>#消息中间件通常采用的几种持久化方式
>	1.持久化到数据库，例如Mysql
>	2.持久化到KV存储，例如levelDB、伯克利DB等KV存储系统
>	3.文件记录形式持久化，例如Kafka，RocketMQ
>	4.对内存数据做一个持久化镜像，例如beanstalkd，VisiNotify
>	5.RocketMQ充分利用Linux文件系统内存cache来提高性能
>```

##### 2.6Message Reliablity

>```sh
>#影响消息可靠性的几种情况：
>	1.Broker正常关闭
>	2.Broker异常Crash
>	3.OS Crash
>	4.机器掉电，但是能立即恢复供电情况
>	5.机器无法开机（可能是cpu、主板、内存等关键设备损坏）
>	6.磁盘设备损坏
>#(1)、(2)、(3)、(4)四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据
>
>#(5)、(6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用,RocketMQ从3.0版本开始支持同步双写.
>```

##### 2.7Low Latency Messaging

>```sh
>在消息不堆积情况下，消息到达Broker后，能立刻到达Consumer
>RocketMQ使用长轮询Pull方式，可保证消息非常实时，消息实时性不低于Push
>```

##### 2.8At least Once

>```sh
>#是指每个消息必须投递一次
>RocketMQ Consumer先pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持此特性
>```

##### 2.9Exactly Only Once

>```sh
>1.发送消息阶段，不允许发送重复的消息
>2.消费消息阶段，不允许消费重复的消息
>#只有以上两个条件都满足情况下，才能认为消息是“Exactly Only Once”，而要实现以上两点，在分布式系统环境下，不可避免要产生巨大的开销。所以RocketMQ为了追求高性能，并不保证此特性，要求在业务上进行去重，也就是说消费消息要做到幂等性。RocketMQ虽然不能严格保证不重复，但是正常情况下很少会出现重复发送、消费情况，只有网络异常，Consumer启停等异常情况下会出现消息重复
>```

##### 2.10Broker的Buffer满了怎么办？

>```sh
>Broker的Buffer通常指的是Broker中一个队列的内存Buffer大小，这类Buffer通常大小有限，如果Buffer满了以后怎么办？
>	1.RocketMQ没有内存Buffer概念，RocketMQ的队列都是持久化磁盘，数据定期清除
>	2.RocketMQ同其他MQ有非常显著的区别，RocketMQ的内存Buffer抽象成一个无限长度的队列，不管有多少数据进来都能装得下，这个无限是有前提的，Broker会定期删除过期的数据，例如Broker只保存3天的消息，那么这个Buffer虽然长度无限，但是3天前的数据会被从队尾删除
>#此问题的本质原因是网络调用存在不确定性，即既不成功也不失败的第三种状态，所以才产生了消息重复性问题
>```

##### 2.11回溯消费

>```sh
>#回溯消费是指Consumer已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker在向Consumer投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于Consumer系统故障，恢复后需要重新消费1小时前的数据，那么Broker要提供一种机制，可以按照时间维度来回退消费进度。
>
>RocketMQ支持按照时间回溯消费，时间维度精确到毫秒，可以向前回溯，也可以向后回溯。
>```

##### 2.12消息堆积

>```sh
>
>```
>
>
























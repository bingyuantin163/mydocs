#  消息队列中间件

## 消息队列的应用场景

```sh
    消息队列中间件主要是分布式系统中的重要组件，主要解决异步消息，应用解耦，流量销峰等问题，从而实现高性能、高可用、可伸缩和最终一致性架构
```

### 异步处理

>```sh
>#场景说明：用户注册后需要发送注册邮件和注册短信
>```
>
>```sh
>2.引入消息队列：异步处理，注册消息写入数据库后即返回客户端注册成功
>```
>

### 应用解耦

>```sh
>#场景说明：用户下单后，下单系统需要通知库存系统
>```
>
>```sh
>1.传统做法：订单系统调用库存系统接口，待库存系统正确返回给订单系统，订单系统才会返回客户端下单成功
>     缺点：假如库存系统无法访问，订单减库存将失败，从而下单失败，订单系统与库存系统耦合	
>```
>
>```sh
>2.引入消息队列：
>订单系统：用户下单后，订单系统完成持久化处理，将消息写入队列，就可返回用户，下单成功
>库存系统：订阅下单消息，获取下单信息，库存消息根据下单信息，进行库存操作
>  假如：下单时库存系统不能正常使用，也不会影响正常下单。因为下单后，系统写入消息队列后就不再关心后续操作了
>    实现订单系统与库存系统的应用解耦	
>  ```
>     

### 流量销峰

>```sh
>#应用场景：秒杀活动一般因为流量过大，导致流量暴增，应用挂掉
>```
>
>```sh
>1.引入消息队列：
>  可以控制活动人数、可以缓解短时间内高流量压垮应用
>  用户请求，服务器接收后，先写入消息队列，假如消息队列超过最大数量，则直接抛弃用户或返回错误页面
>  秒杀业务根据消息队列中的请求消息，再做后续处理	
>```
>

## 消息队列主要用来解决那些问题

### Publish/Subscribe

>```sh
>订阅发布是消息中间件最基本功能
>```

### Message Priority

>```sh
>  RocketMQ所有消息都是持久化的，所以按照优先级来排序，开销会非常大，因此RocketMQ没有特意支持消息优先级
>  但是可以通过变通的方式实现类似功能，即单独配置一个优先级高的队列，和一个普通优先级别队列，将不同优先级
>  发送到不同队列即可
>  	1.只要达到优先级别目的即可，不是严格意义上的优先级，通常将优先级分为高、中、低或者再多几个级别，每个		  优先级可以用不同topic来表示，发消息时，指定不同topic来表示优先级，这种方式可以解决大部分的优先级		  问题，但是对业务优先级精确性做了拖鞋
>  	2.严格的优先级，用整数0~65535表示，这种优先级问题一般用不同topic解决就非常不合适。如果要让MQ解决此	   问题，会对MQ性能造成非常大的影响。需要明确一点，业务上是否确实需要这种严格的优先级，如果将优先级压	   缩成几个，对业务影响有多大
>```

### 2.3Message Order

>```sh
>  消息有序指的是一类消息消费时，能按照发送的顺序来消费。
>  如：一个订单产生三条消息，分别是订单创建，订单付款，订单完成。消费时，按照这个顺序消费才有意义，单同时订	   单直接可以并行消费。
>  RocketMQ可以严格保证消息有序
>```

### Message Filter

>```sh
>  	1.Broker端消息过滤
>  		在Broker中，按照Consumer的要求做过滤，优点是减少了对于Consumer无用消息的网络传输
>  		缺点是增加了Broker的负担，实现相对复杂
>  	2.Consumer端消息过滤
>  		这种过滤方式可由应用完全自定义实现，但是缺点是很多无用的消息要传输到Consumer端
>```

### Message Persistence

>```sh
>#消息中间件通常采用的几种持久化方式
>	1.持久化到数据库，例如Mysql
>	2.持久化到KV存储，例如levelDB、伯克利DB等KV存储系统
>	3.文件记录形式持久化，例如Kafka，RocketMQ
>	4.对内存数据做一个持久化镜像，例如beanstalkd，VisiNotify
>	5.RocketMQ充分利用Linux文件系统内存cache来提高性能
>```

### Message Reliablity

>```sh
>#影响消息可靠性的几种情况：
>	1.Broker正常关闭
>	2.Broker异常Crash
>	3.OS Crash
>	4.机器掉电，但是能立即恢复供电情况
>	5.机器无法开机（可能是cpu、主板、内存等关键设备损坏）
>	6.磁盘设备损坏
>#(1)、(2)、(3)、(4)四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据
>
>#(5)、(6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用,RocketMQ从3.0版本开始支持同步双写.
>```

### Low Latency Messaging

>```sh
>在消息不堆积情况下，消息到达Broker后，能立刻到达Consumer
>RocketMQ使用长轮询Pull方式，可保证消息非常实时，消息实时性不低于Push
>```

### At least Once

>```sh
>#是指每个消息必须投递一次
>RocketMQ Consumer先pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持此特性
>```

### Exactly Only Once

>```sh
>1.发送消息阶段，不允许发送重复的消息
>2.消费消息阶段，不允许消费重复的消息
>#只有以上两个条件都满足情况下，才能认为消息是“Exactly Only Once”，而要实现以上两点，在分布式系统环境下，不可避免要产生巨大的开销。所以RocketMQ为了追求高性能，并不保证此特性，要求在业务上进行去重，也就是说消费消息要做到幂等性。RocketMQ虽然不能严格保证不重复，但是正常情况下很少会出现重复发送、消费情况，只有网络异常，Consumer启停等异常情况下会出现消息重复
>```

### Broker的Buffer满了怎么办？

>```sh
>Broker的Buffer通常指的是Broker中一个队列的内存Buffer大小，这类Buffer通常大小有限，如果Buffer满了以后怎么办？
>	1.RocketMQ没有内存Buffer概念，RocketMQ的队列都是持久化磁盘，数据定期清除
>	2.RocketMQ同其他MQ有非常显著的区别，RocketMQ的内存Buffer抽象成一个无限长度的队列，不管有多少数据进来都能装得下，这个无限是有前提的，Broker会定期删除过期的数据，例如Broker只保存3天的消息，那么这个Buffer虽然长度无限，但是3天前的数据会被从队尾删除
>#此问题的本质原因是网络调用存在不确定性，即既不成功也不失败的第三种状态，所以才产生了消息重复性问题
>```

### 回溯消费

>```sh
>#回溯消费是指Consumer已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker在向Consumer投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于Consumer系统故障，恢复后需要重新消费1小时前的数据，那么Broker要提供一种机制，可以按照时间维度来回退消费进度。
>
>RocketMQ支持按照时间回溯消费，时间维度精确到毫秒，可以向前回溯，也可以向后回溯。
>```

### 消息堆积

>```sh
>#消息中间键的主要功能是：
>1.异步解耦
>2.挡住前端的数据，保证后端系统的稳定性
>#要求消息中间键拥有一定的消息堆积能力：
>1.消息堆积在内存buffer，一旦超过内存buffer，可以根据一定的丢弃策略来丢弃消息，如CORBA Notification规范
>中描述，适合能容忍丢弃消息的业务，这种情况消息的堆积能力主要在于内存的buffer大小，而且消息堆积后，性能下降
>不会太大，因为内存中的数据多少对于对外提供的访问能力影响有限
>2.消息堆积能持久化存储系统中，例如DB,KV存储，文件记录形式.当消息不能在内存Cache命中时，要不可避免的访问磁
>盘，会产生大量读IO，读IO的吞吐量直接决定了消息堆积后的访问能力
>#评估消息堆积能力
>1.消息堆积多少条，多少字节？即消息堆积容量
>2.消息堆积后，发消息的吞吐量大小，是否会受堆积影响
>3.消息堆积后，正常消费的Consumer是否会受影响
>4.消息堆积后，访问堆积在磁盘的消息时，吞吐量多大
>```
>

### 分布式事务

```sh
已知的几个分布式事务规范，如XA，JTA等。其中XA规范被各大数据库厂商广泛支持，如Oracle，Mysql等，其中XA的TM实现佼佼
者如Oracle Tuxedo，在金融、电信等领域被广泛应用
#分布式事务涉及到两个阶段提交问题
在数据存储方面必然需要KV存储的支持，因为第二阶段的提交回滚需要修改消息状态，一定涉及到根据key去查找Message的动作，
RocketMQ在第二阶段绕过了根据Key去查找Message的问题，采用第一阶段发送Prepared消息时，拿到了消息的Offset，第二阶
段通过Offset去访问消息，并修改状态，Offset就是数据的地址

RocketMQ这种实现事务的方式，没有通过KV存储做，而是通过Offset方式，存在一个显著缺陷，即通过Offset更改数据，会令系
统的脏页过多，需要特别关注
```

### 定时消息

```sh
#定时消息
是指消息发送到Broker后，不能立刻被Consumer消费，要到特定的时间点或者等待特定的时间后才能被消费
如果要支持任意的时间精度，在Broker层面，必须要做消息排序，如果在涉及到持久化，那么消息排序要不可避免的产生巨大性能
开销
RoketMQ支持定时消息，但是不支持任意时间精度，支持特定的level，例如定时5s，10s，1m等
```

### 消息重试

```sh
#Consumer消费消息失败后，要提供一种重试机制，令消息再消费一次，Consumer消费消息失败通常可以认为有以下几种情况：

```



## rocketmq环境部署

### 主机环境

| HOST | IP            | SERVER   |      |
| ---- | ------------- | -------- | ---- |
| vm6  | 192.168.220.6 | rocketmq |      |
| vm7  | 192.168.220.7 | rocketmq |      |
| vm8  | 192.168.220.8 | rocketmq |      |

### 服务环境

```sh
1.#需要登录相应的oracle账户,下载java包
首页 https://www.oracle.com/cn/java/technologies/javase-jdk8-downloads.html
jdk-8u251-linux-x64.tar.gz  下载到本地，然后上传到linux服务器上
2.#解压
tar -zxvf jdk-8u251-linux-x64.tar.gz
mkdir /usr/local/java
mv jdk1.8.0_251/*  /usr/local/java/
3.#设置环境变量
echo -e "export JAVA_HOME=/usr/local/java\nexport 
                JRE_HOME=\${JAVA_HOME}/jre\nexport 
                CLASSPATH=.:\${JAVA_HOME}/lib:\${JRE_HOME}/lib\nexport 
                PATH=\${JAVA_HOME}/bin:\$PATH" >> /etc/profile
source /etc/profile
which java
```

### 下载安装

#### 安装mvn

```sh
1.#下载mvn
wget https://apache.01link.hk/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz
tar xf apache-maven-3.6.3-bin.tar.gz -C /usr/local/
2.#设置环境变量
echo -e "export MAVEN_HOME=/usr/local/apache-maven-3.6.3\nexport 
                      PATH=\$PATH:\$MAVEN_HOME/bin" >> /etc/profile
source /etc/profile
which mvn
/usr/local/apache-maven-3.6.3/bin/mvn  --version

```

#### 安装rocketmq

```sh
1.#获取reocketmq
wget https://archive.apache.org/dist/rocketmq/4.6.0/rocketmq-all-4.6.0-source-release.zip
unzip rocketmq-all-4.6.0-source-release.zip
cd rocketmq-all-4.6.0-source-release
2.#使用mvn编译
mvn -Prelease-all -DskipTests clean install -U
3.#把所编译的目录放到指定位置
mkdir /data/rocketmq
cd distribution/target/rocketmq-4.6.0/rocketmq-4.6.0/
cp -r  * /data/rocketmq
scp conf/2m-noslave/broker-a.properties vm7:/data/rocketmq/conf/2m-noslave/broker-a.properties 
scp conf/2m-noslave/broker-a.properties vm8:/data/rocketmq/conf/2m-noslave/broker-a.properties 
4.#启动mqnamesrv
nohup sh /data/rocketmq/bin/mqnamesrv &
nohup sh /data/rocketmq/bin/mqbroker -c /data/rocketmq/conf/2m-noslave/broker-a.properties &
（虚拟机上搭建这里可能出现Cannot allocate memory错误，需要在修改runbroker.sh中的内存设置）
（JAVA_OPT="${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn125m" #根据本机内存改为适合自己的大小即可）
5.#列出集群信息
sh /data/rocketmq/bin/mqadmin clusterList -n 192.168.220.6:9876
```

#### 控制台(可选)

```sh
#RocketMQ Console
主要是针对RocketMQ所做的一个界面管理工具，方便后期的运维管理，查看当前的MQ使用情况，包括Producer、Consumer、
Broker、Topic甚至Msg的管理。当然了，如果你比较喜欢命令行的形式也可以使用bin目录下的mqadmin来去管理
```

```sh
1.#安装控制台
git clone -b release-rocketmq-console-1.0.0 https://github.com/apache/rocketmq-externals.git
或者
wget https://github.com/bingyuantin163/mydocs/releases/download/1.0.0/rocketmq-externals-rocketmq-console-1.0.0.tar.gz
2.#控制台配置文件
cd rocketmq-externals/rocketmq-console/src/main/resources/
vim application.properties
3.#编译安装
#这里需要在pom.xml所在的目录下执行，这里是/root/rocketmq-externals-rocketmq-console-1.0.0/rocketmq-console
mvn clean package -Dmaven.test.skip=true
cp target/rocketmq-console-ng-1.0.0.jar /data/rocketmq/
nohup java -jar /data/rocketmq/rocketmq-console-ng-1.0.0.jar &
4.#访问控制台
http://192.168.220.6:8080
5.#容器方式(可尝试容器化部署)
docker pull styletang/rocketmq-console-ng
docker run -d -e "JAVA_OPTS=-Drocketmq.namesrv.addr=127.0.0.1:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false" -p 8080:8080 -t styletang/rocketmq-console-ng 
6.#将127.0.0.1修改为nameserver地址
```

#### 配置文件

```sh
1.cat  /data/rocketmq/conf/2m-noslave/broker-a.properties
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
brokerClusterName=DefaultCluster
# 其他节点换成 broker-b，broker-c
brokerName=broker-a
brokerId=0
deleteWhen=04
fileReservedTime=120
brokerRole=ASYNC_MASTER
flushDiskType=ASYNC_FLUSH
namesrvAddr=192.168.220.6:9876;192.168.220.7:9876;192.168.220.8:9876

2.cat rocketmq-externals-rocketmq-console-1.0.0/rocketmq-console/src/main/resources/application.properties
server.contextPath=
server.port=8080
#spring.application.index=true
spring.application.name=rocketmq-console
spring.http.encoding.charset=UTF-8
spring.http.encoding.enabled=true
spring.http.encoding.force=true
logging.config=classpath:logback.xml
#if this value is empty,use env value rocketmq.config.namesrvAddr  NAMESRV_ADDR | now, you can set it in ops page.default localhost:9876
rocketmq.config.namesrvAddr=192.168.220.6:9876;192.168.220.7:9876;192.168.220.8:9876
#if you use rocketmq version < 3.5.8, rocketmq.config.isVIPChannel should be false.default true
rocketmq.config.isVIPChannel=
#rocketmq-console's data path:dashboard/monitor
rocketmq.config.dataPath=/tmp/rocketmq-console/data
#set it false if you don't want use dashboard.default true
rocketmq.config.enableDashBoardCollect=true
```

#### 配置详解

```sh
#所属集群名字
brokerClusterName=rocketmq-cluster
#broker名字，注意此处不同的配置文件填写的不一样，a.properties,就写broker-a，b的就填写b
brokerName=broker-a
#0 表示 Master，>0 表示 Slave
brokerId=0
#nameServer地址，分号分割
namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876;rocketmq-nameserver3:9876
#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数
defaultTopicQueueNums=4
#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭
autoCreateTopicEnable=true
#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭
autoCreateSubscriptionGroup=true
#Broker 对外服务的监听端口
listenPort=10911
#删除文件时间点，默认凌晨 4点
deleteWhen=04
#文件保留时间，默认 48 小时
fileReservedTime=120
#commitLog每个文件的大小默认1G
mapedFileSizeCommitLog=1073741824
#ConsumeQueue每个文件默认存30W条，根据业务情况调整
mapedFileSizeConsumeQueue=300000
#destroyMapedFileIntervalForcibly=120000
#redeleteHangedFileInterval=120000
#检测物理文件磁盘空间
diskMaxUsedSpaceRatio=88
#存储路径
storePathRootDir=/mnt/store
#commitLog 存储路径
storePathCommitLog=/mnt/store/commitlog
#消费队列存储路径存储路径
storePathConsumeQueue=/mnt/store/consumequeue
#消息索引存储路径
storePathIndex=/mnt/store/index
#checkpoint 文件存储路径
storeCheckpoint=/mnt/store/checkpoint
#abort 文件存储路径
abortFile=/mnt/store/abort
#限制的消息大小
maxMessageSize=65536
#flushCommitLogLeastPages=4
#flushConsumeQueueLeastPages=2
#flushCommitLogThoroughInterval=10000
#flushConsumeQueueThoroughInterval=60000 
#Broker 的角色
#- ASYNC_MASTER 异步复制Master
#- SYNC_MASTER 同步双写Master
#- SLAVE
brokerRole=ASYNC_MASTER
#刷盘方式
#- ASYNC_FLUSH 异步刷盘
#- SYNC_FLUSH 同步刷盘
flushDiskType=ASYNC_FLUSH
#checkTransactionMessageEnable=false
#发消息线程池数量
#sendMessageThreadPoolNums=128
#拉消息线程池数量
#pullMessageThreadPoolNums=128
brokerIP1=172.16.150.134 #绑定本地IP，如果主机有多块网卡则需要配置，否则报错
```


学习笔记：Kubernetes.in.Action

1.kubernetes介绍

>1.kubernetes系统需求
>
>```shell
>1.单体应用到微服务（应用开大和部署在近些年的发展趋势）
>```
>
>>```shell
>>#单体应用：
>>	1.多个组件	2.紧密耦合	3.边界定义缺乏	4.系统复杂度提升	5.增长系统负荷
>>	6.垂直扩展（成本、瓶颈）	7.水平扩展（程序代码限制）
>>```
>>
>>```shell
>>#单体应用拆分为多个微服务
>>	1.独立部署	2.独立进程	3.接口通信（静态API）	4.协议通信	5.不局限编程语言
>>	6.独立开发	7.服务间改动依赖减小
>>```
>>
>>```shell
>>#微服务扩容
>>	1.针对单个服务	2.多个微服务	3.可以扩容的进行水平扩展	4.不可扩容进行垂直扩展	
>>```
>>
>>```shell
>>#部署微服务
>>	1.少许组件容易	2.组件增加、冗杂易错	3.扩机器和程序、调试代码和定位异常变得困难
>>	4.被分布式（如Zipkin）定位系统解决
>>```
>>
>>```shell
>>#环境需求差异
>>	1.独立开发组件导致需求环境的差异	2.多应用在同一台主机上运行可能会有依赖冲突
>>	3.同一主机上部署的组件越大，满足这些组件的需求就越难
>>```
>
>```shell
>2.为应用程序提供一个一致环境
>```
>
>>```shell
>>#减少仅在生产才会暴露的问题，最理想的做法是让程序在开发和生产阶段可以处在完全一样的环境下。
>>	1.操作系统	2.版本库	3.系统配置	4.网络环境	5.其他所有条件
>>```
>
>```shell
>3.迈向持续交付：Devops和无运维
>```
>
>>```shell
>>#让同一个团队参与应用的开发，部署，运维的整个生命周期，这意味着开发者、QA、和运维团队彼此之间的合作需要贯穿整个流程。这种实践被称为DevOps。
>>```
>>
>>```shell
>>#带来优点
>>	1.开发者更好理解用户以及运维团队问题	2.简化部署流程，理想状态开发人员可以自己部署上线
>>```
>>
>>```shell
>>#让开发者和系统管理员做他们最擅长的
>>	1.开发者热衷于创造新功能和提升用户体验
>>	2.运维团队热衷于系统安全、使用率、部署流程、硬件基础设置
>>```
>>
>>```shell
>>#kubernetes让我们实现某些想法
>>	1.抽象实际硬件，将自身暴露成一个平台，用于部署个运行环境
>>	2.允许开发者部署和配置应用程序，而不需要系统管理员的任何帮助
>>	3.系统管理员聚焦保持底层基础设施运转正常的同时，不需要关注实际运行在平台上的应用程序
>>```
>
>2.介绍容器技术
>
>```shell
>1.容器实现隔离技术
>```
>
>>```shell
>>#两个机制
>>	1.Linux的命名空间，它使每个进程只看到自己的系统视图（文件、进程、网络接口、主机名等）
>>	2.Linux控制组（cgroups），它限制了进程能够使用的资源量（CPU、内存、网络宽带等）
>>```
>>
>>```sh
>>#linux命名空间隔离进程
>>	1.默认情况，每个Linux系统最初仅有一个命名空间，所有系统资源属于这一个命名空间
>>	2.可以创建额外的命名空间，以及在它们之间创建资源
>>	3.对于一个进程，可以在其中一个命名空间运行它。进程就只能看到同一命名空间下的的资源
>>	4.存在多种类型的多个命名空间，一个进程不单单属于某一个命名空间，而属于每个类型的一个命名空间
>>		存在以下类型的命名空间：
>>		1.Mount(mnt)
>>		2.Process ID(pid)
>>		3.Network(net)
>>		4.Inter-process communication(ipd)
>>		5.UTS
>>		6.User ID(user)
>>	5.每种命名空间被用来隔离一组特定资源，UTS命名空间决定了运行在命名空间里的进程能够看到那些主	  机名和域名，通过分派两个不同的UTS命名空间给一对进程，能使它们看见不同的本地主机名，两个进	  程就好像在两个不同的机器上运行一样（至少就主机名而言是这样）
>>```
>>
>>```shell
>>#linux的cgroups限制进程可用资源
>>	1.linux的内核功能
>>	2.限制一个进程或者一组进程的资源使用
>>	3.不能超出被分配的资源量（CPU、内存、网络宽带等）
>>```
>
>```sh
>2.docker容器平台介绍
>```
>
>>```shell
>>#Docker的概念
>>	1.第一个使容器在不同机器之间移植的系统
>>	2.不关心部署的服务器是否安装了和你打包的应用使用相同的系统
>>		（用RHEL打包的应用在Debian或者其他的Fedora上运行，应用程序只认为它运行在RHEL上）
>>	3.docker是一个打包、分发和运行应用程序的平台
>>		1.允许将应用程序和所依赖的整个环境打包在一起（镜像）
>>		2.docker传输这个包到一个中央仓库（镜像仓库）
>>		3.分发到各个机器被执行（容器）
>>```
>>
>>```sh
>>#rkt——一个docker的替代方案
>>	1.docker本身并不提供进程隔离，由内核完成
>>	2.rkt是另外一个Linux容器引擎
>>	3.强调安全性，可构建性并遵从开放标准
>>	4.使用OCI开放容器计划容器镜像，甚至可以运行常规的docker镜像容器
>>	5.docker是kubernetes最初唯一支持的容器类型，最近也开始支持rkt
>>	6.kubernetes不是一个专为docker容器设计的容器编排系统，kubernetes的核心远不止编排容器
>>```
>
>3.Kubernetes介绍
>
>```shell
>1.初衷
>```
>
>>```sh
>>1.Google开发出来一个叫Borg的内部系统，后来开发一个新的叫Omega的系统，简化开发和管理
>>2.保守Borg和Omega秘密数十年后，2014年Google开放了Kubernetes
>>3.一个基于Borg、Omega及其他谷歌内部系统实践的开源系统
>>```
>
>```sh
>2.简单了解k8s
>```
>
>>```sh
>>1.一款软件系统
>>2.容易部署和管理容器化的系统
>>3.将底层基础抽象，Kubernetes使在数以千计的电脑节点上运行软件时就像所有这些节点使单个大节点一样
>>4.集群规模不会造成什么差异性，额外的集群节点只是代表一些额外可用来部署应用的资源
>>```
>>
>>​                                                                                                      ![image-20191218160513377](C:\Users\Owner\AppData\Roaming\Typora\typora-user-images\image-20191218160513377.png)
>
>```shell
>3.K8s的集群架构
>```
>
>>```sh
>>1.主节点：控制和管理整个集群系统的控制面板
>>2.工作节点：运行用户实际部署的应用
>>```
>>
>>![image-20191218160836837](C:\Users\Owner\AppData\Roaming\Typora\typora-user-images\image-20191218160836837.png)																																																				
>>
>>```sh
>>#控制面板（组件）
>>	1.Kubernetes API服务器，都要和它通信
>>	2.Schduler，它调度你的应用（为应用的每个部署组件分配一个工作节点）
>>	3.Controller Manager，它执行集群级别的功能，如辅助组件，持续跟踪工作节点，处理节点失败等
>>	4.Etecd,一个可靠的分布式数据存储，能够持久化存储集群配置
>>```
>>
>>```shell
>>#工作节点
>>	1.运行docker、rkt或者其他组件类型
>>	2.Kubelet，它与API服务器通信，并管理它所在的节点的容器
>>	3.Kubernetes Service Proxy (kube-proxy)，负责组件之间的负载均衡网络流量
>>```
>
>4.在Kubernetes中运行应用
>
>>```sh
>>1.描述信息怎样成为一个运行的容器
>>	#为了在K8s中运行应用，首先需要将应用打包进一个或多个容器镜像，再将镜像推送到镜像仓库，然后应用的描述发布到Kubernetes API服务器
>>	1.APP descriptor应用描述符列出容器并分组，组称为pod，同时确定需要运行每个pod的数量
>>	2.在想Kubernetes提交描述符后，它将把每个pod的指定副本数量调度到可用的工作节点上
>>	3.节点上的kebelet将告知docker从镜像仓库中拉取容器镜像并运行容器
>>```
>>
>>```sh
>>2.保持容器运行
>>	1.k8s不断地确认应用程序部署状态，始终与提供的描述想匹配，当进程崩溃或停止响应，自动重启
>>	2.如果整个工作节点死亡或者无法访问，k8s将故障节点运行的所有容器选择新节点，并运行
>>```
>>
>>![image-20191218174504982](C:\Users\Owner\AppData\Roaming\Typora\typora-user-images\image-20191218174504982.png)
>>
>>```sh
>>3.扩展副本数量
>>	1.kubernetes可以增加副本或者停止多余副本
>>	2.甚至可以把决定最佳副本数量交给kubernetes
>>	3.可以根据实时指标（如CPU消耗、内存消耗、每秒查询或公开的其他指标）自动调整副本数量
>>```
>>
>>```sh
>>4.命中移动容器
>>	1.运行节点失败，为其他容器腾地方等情况会导致容器迁移
>>	2.容器向运行在集群中的其他容器提供服务或者客户端提供服务，当容器在集群中频繁调度时
>>	3.如何正确使用该容器？容器被复制并分布整个集群时，客户端如何连接到提供服务的容器呢？
>>	4.Kubernetes将通过一个静态IP地址暴露所有容器，并将该地址暴露给集群中运行的所有应用程序
>>	5.环境变量完成或者通过良好的DNS查找服务IP
>>	6.kube-proxy将确保到服务的连接可跨提供服务的容器实现负载均衡
>>	7.服务的IP地址保持不变，客户端始终可以连接到它的容器
>>```
>
>5.使用Kubernetes的好处
>
>```sh
>1.简化应用程序部署
>2.更好地利用硬件
>3.健康检查和自修复
>4.自动扩容
>```

2.开始使用Kubernetes和Docker

>1.创建、运行及共享容器镜像
>
>>```sh
>>1.安装Docker并运行容器
>>http://docs.docker.corn/ engine/installation/  按照此文档安装即可
>>```
>>
>>```sh
>>2.运行Hello World容器
>>#busybox是一个单一可执行文件，包含多种标准UNIX命令工具：echo、ls、gzip等
>>docker run  busybox echo "Hello World"
>>```
>>
>>```shell
>>3.创建一个简单的Node.js应用
>>	1.构建一个简单的Node.js Web应用，并把它打包到容器镜像中
>>	2.这个应用会接受HTTP请求并响应应用的主机名
>>	3.Node.js代码清单
>>const http = require('http');
>>const os = require('OS');
>>console.log("Kubia server starting...");
>>var handler = function(request, response) {
>>  console.log("Received request from " + request.connection.remoteAddress);
>>  response.writeHead(200);
>>  response.end("You've hit " + os.hostname() + "\n");
>>};
>>var www = http.createServer(handler);
>>www.listen(8080);
>>	4.这里的8080端口启动一个HTTP服务器；服务器会以状态码200 OK和文字"You've hit <hostname>"
>>	  来响应每个请求。请求Handler 会把客户端的IP打印到标准输出，以便日后查看。
>>```
>>
>>```sh
>>4.为镜像创建Dockerfile
>>	FROM node:7
>>	ADD app.js /app.js
>>	ENTRYPOINT ["node", "app.js"]
>>#为什么非要用node这个基础镜像，因为运行的是Node.js应用，镜像需要包含可执行的node二进制文件来运行应用，也可以使用其他包含这个二进制文件的镜像，或者甚至可以使用Linux发型版的基础镜像，然后在构建时候暗转Node.js。但是由于node镜像是专门用来运行Node.js应用的，并且包含了应用所需的一切，所以把它当做基础镜像。
>>```
>>
>>```sh
>>5.构建容器镜像
>>docker build -t kubia .
>>```
>>
>>![image-20191218185840833](C:\Users\Owner\AppData\Roaming\Typora\typora-user-images\image-20191218185840833.png)
>>
>>```sh
>>#镜像是如何构建的
>>	1.执行命令
>>	2.Docker客户端将整个目录文件Docker守护进程并在那里进行
>>	3.Docker的客户端和守护进程不要求在同一台机子上
>>	4.构建的文件上传到守护进程，可能时间比较久
>>	5.Docker首次会从公开的镜像仓库（Docker Hub）拉取基础镜像，除非已经拉去过
>>```
>>
>>```sh
>>6.运行镜像
>>docker run --name kubia-container -p 8080:8080 -d kubia
>>
>>#尝试访问  curl localhost:8080
>>#详细信息  docker inspect kubia-container  
>>		#docker  会打印出包含容器底层信息的长JSON
>>```
>>
>>```sh
>>7.向镜像仓库推送镜像
>>docker login
>>docker tag kubia  docker.io/bingyuantin/kubia
>>docker push docker.io/bingyuantin/kubia
>>```
>
>2.配置Kubernetes集群



























































































































>>










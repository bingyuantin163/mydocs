# nginx相关内容

## location匹配

### 语法规则

```sh
location [ = | ~ | ~* | ^~ ] uri { ... }
location @name { ... }
语法规则很简单，一个location关键字，后面跟着可选的修饰符，后面是要匹配的字符，花括号中是要执行的操作
```

### 修饰符

```sh
= 表示精确匹配，只有请求的url路径与后面的字符串完全相等时，才会命中
~ 表示该规则是使用正则定义的，区分大小写
~* 表示该规则是使用正则定义的，不区分大小写
^~ 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找
```

### 匹配过程

```sh
#location有两种表示形式，一种是使用前缀字符，一种是使用正则
##具体匹配过程
	首先先检查使用前缀字符定义的location，选择最长匹配的项并记录下来
	如果找到了精确匹配的location，也就是使用了=修饰符的location，结束查找，使用它的配
	然后按顺序查找使用正则定义的location，如果匹配则停止查找，使用它定义的配置
	如果没有匹配的正则location，则使用前面记录的最长匹配前缀字符location
###启示
	使用正则定义的location在配置文件中出现的顺序很重要，找到第一个正则后，查找停止，后面定义正不会匹配
	使用精确匹配可以提高查找的速度，经常请求/的话，可以使用=来定义location
```

### 实例

```sh
location = / {
    [ configuration A ]
}

location / {
    [ configuration B ]
}

location /user/ {
    [ configuration C ]
}

location ^~ /images/ {
    [ configuration D ]
}

location ~* \.(gif|jpg|jpeg)$ {
    [ configuration E ]
}
#请求/精准匹配A，不再往下查找
#请求/index.html匹配到B，先查找前缀匹配，找到最长匹配B，再按照顺序匹配正则，未找到，匹配先前标记最长B
#请求/usr/index.html匹配到C，匹配前缀字符最长找到C标记，匹配正未找到...
#请求/usr/1.jpg匹配E，匹配前缀字符最长找到C，匹配正则找到E...
#请求/images/1.jpg匹配D，匹配前缀字符找到最长D，但是特殊使用了^~,不再进行接下来的正则匹配
#请求/documents/about.html匹配B，匹配前缀字符最长为B，因为B表示任何以/开头的url都匹配，A是精准匹配
```





















